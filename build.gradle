plugins {
	id 'java-gradle-plugin'
	id 'jvm-test-suite'
	id 'org.checkerframework'
	id 'groovy'

	id 'com.gradle.plugin-publish'

	id 'com.github.spotbugs'
	id 'checkstyle'
	id 'pmd'

	id 'org.unbroken-dome.gitversion'

	id 'idea'
}

java {
	sourceCompatibility = JavaVersion.VERSION_17
	targetCompatibility = JavaVersion.VERSION_17

	consistentResolution {
		useCompileClasspathVersions()
	}
}

checkerFramework {
	checkers = [
		'org.checkerframework.checker.nullness.NullnessChecker',
		'org.checkerframework.common.initializedfields.InitializedFieldsChecker',
		'org.checkerframework.checker.formatter.FormatterChecker',
		'org.checkerframework.common.value.ValueChecker'
	]
}

testing {
	suites {
		test(JvmTestSuite) {
			useSpock()
		}

		integrationTest(JvmTestSuite) {
			useSpock()

			dependencies {
				implementation project()
			}
		}

		functionalTest(JvmTestSuite) {
			useSpock()
		}
	}
}

gradlePlugin {
	website.set('https://github.com/birdflyer-lszo/gradle-singlular-node')
	vcsUrl.set('https://github.com/birdflyer-lszo/gradle-singlular-node')

	plugins {
		singularNode {
			id = 'com.brunoritz.gradle.singular-node'
			implementationClass = 'com.brunoritz.gradle.singularnode.SingularNodePlugin'
		}
	}

	testSourceSets(sourceSets.integrationTest)
	testSourceSets(sourceSets.functionalTest)
}

configurations {
	integrationTestImplementation.extendsFrom testImplementation
}

dependencies {
	testImplementation(platform('org.spockframework:spock-bom:2.1-groovy-3.0'))

	implementation 'com.github.spotbugs:spotbugs-annotations:4.7.3'
	implementation 'io.vavr:vavr:0.10.4'
	implementation 'net.jcip:jcip-annotations:1.0'

	testImplementation 'cglib:cglib-nodep:3.3.0'
	testImplementation 'org.spockframework:spock-core'
	testImplementation 'org.spockframework:spock-junit4'
	testImplementation 'junit:junit:4.13.2'
}

spotbugs {
	excludeFilter.set(file('config/spotbugs-exclusions.xml'))
	showStackTraces.set(false)

	effort = 'max'
}

spotbugsMain {
	reports {
		xml {}
	}
}

spotbugsIntegrationTest {
	enabled = false
}

spotbugsFunctionalTest {
	enabled = false
}

pmd {
	toolVersion = '6.33.0'
	consoleOutput = true
	ruleSets = []
	reportsDir = file("${buildDir}/reports/pmd")
	ruleSetFiles = files("${rootDir}/config/pmd-rules.xml")
	ignoreFailures = true
}

gitVersion {
	rules {
		def releaseVersionTag = ~/v(?<major>\d+)\.(?<minor>\d+)\.(?<patch>\d+)/

		before {
			def releaseVersion = findLatestTag(releaseVersionTag)

			version.major = releaseVersion ? releaseVersion.matches['major'].toInteger() : 0
			version.minor = releaseVersion ? releaseVersion.matches['minor'].toInteger() : 0
			version.patch = releaseVersion ? releaseVersion.matches['patch'].toInteger() : 0
		}

		/*
		 * On a feature branch the build version is either
		 * - The last release version with its minor version incremented by one and patch level zero
		 * - The version set in the latest "start of development" tag and patch level zero
		 *
		 * The tag representing the higher version number is used.
		 */
		onBranch(~/^(?!master|release\/|hotfix\/).*$/) {
			def latestDevStart = findLatestTag(~/startdev-v(?<major>\d+)\.(?<minor>\d+)/)
			int startMajorVersion = latestDevStart ? latestDevStart.matches['major'].toInteger() : 0
			int startMinorVersion = latestDevStart ? latestDevStart.matches['minor'].toInteger() : 0

			if (latestDevStart &&
				(startMajorVersion > version.major)
				||
				((startMajorVersion == version.major) && (startMinorVersion > version.minor))) {
				version.major = startMajorVersion
				version.minor = startMinorVersion
			} else {
				version.minor += 1
			}

			version.patch = 0
			version.prereleaseTag = 'feature'
			version.buildMetadata = "${new Date().format('yyyyMMdd')}-${head.id(8)}"
		}

		/*
		 * The "develop" branch is treated the same as a feature branch, just the pre-release tag is set to "develop".
		 */
		onBranch('develop') {
			version.prereleaseTag = 'develop'
		}

		/*
		 * The "master" branch is used to build release versions. The pre-release tag is empty. If the commit being
		 * built is tagged with a version number, the exact version of the tag is used; Otherwise the tagged version is
		 * used with its patch level incremented by one.
		 */
		onBranch('master') {
			def latestVersionTag = findLatestTag(releaseVersionTag)

			if (latestVersionTag) {
				int commitsSinceTag = countCommitsSince(latestVersionTag, true)
				int patchVersionIncrement = Math.signum(commitsSinceTag) as int

				version.patch += patchVersionIncrement
			}
		}

		/*
		 * On a release branch the build version is the one indicated in the branch name. The patch level is always set
		 * to zero. The pre-release tag "rc" to denote a release candidate.
		 */
		onBranch(~/release\/(?<major>\d+)\.(?<minor>\d+)/) {
			version.major = matches['major'].toInteger()
			version.minor = matches['minor'].toInteger()
			version.patch = 0
			version.prereleaseTag = 'rc'
		}

		/*
		 * On a hotfix branch the build version is the latest tagged release version with the patch level incremented
		 * by one. The pre-prelse tag is set to "hotfix" to denote a hotfix test build.
		 */
		onBranch(~/hotfix\/.*/) {
			version.patch += 1
			version.prereleaseTag = 'hotfix'
		}
	}
}

group = 'com.brunoritz.gradle'
version = gitVersion.determineVersion()

idea {
	module {
		testSources.from(
			sourceSets.integrationTest.java.srcDirs,
			sourceSets.functionalTest.java.srcDirs
		)

		testResources.from(
			sourceSets.integrationTest.resources.srcDirs,
			sourceSets.functionalTest.resources.srcDirs
		)
	}
}
